<?xml version="1.0" encoding="utf-16"?>
<!-- Generated with EZOut 2.0.1: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>PowerCode</Name>
    <Members>
      <AliasProperty>
        <Name>Extensions</Name>
        <ReferencedMemberName>Extension</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>ExtensionsOf</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets Extensions Of a particular Command
.DESCRIPTION
    Gets the commands that extensions a particular command.
#&gt;
param(
[string]
$InvocationName
)

@(:nextExtension foreach ($extension in $this.Extension) {
    foreach ($attr in $extension.ScriptBlock.Attributes) {
        if ($attr -isnot [ValidatePattern]) { continue }        
        if (
            [regex]::new(
                $attr.RegexPattern,
                $attr.Options,
                [Timespan]'00:00:00.1'
            ).IsMatch($InvocationName)
        ) {
            $extension
            continue nextExtension
        }
    }    
})
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>FindExtensions</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Finds extensions for a module
.DESCRIPTION
    Finds extended commands for a module. 
.EXAMPLE
    $PowerCode.FindExtensions($PowerCode, "$pwd")
#&gt;
$targetModules = @()
$targetPaths = @()
$loadedModules = Get-Module
foreach ($arg in $args) {
    if ($arg -is [Management.Automation.PSModuleInfo]) {
        $targetModules += $arg
    }
    elseif ($arg -is [IO.FileInfo] -or $arg -is [IO.DirectoryInfo]) {
        $targetPaths += $arg
    } 
    elseif ($arg -is [Management.Automation.PathInfo]) {
        $targetPaths += "$arg"
    }
    elseif ($arg -is [string]) {
        $argIsModule = 
            foreach ($module in $loadedModules) { if ($module.Name -like $arg) { $module}}
        if ($argIsModule) {
            $targetModules += $argIsModule
        } elseif (Test-Path $arg) {
            $targetPaths += $arg
        }
        
    }
}

if (-not $targetModules) { $targetModules = $posh.Modules}
$Splat = @{}
if ($targetPaths) {
    $Splat.FilePath = $targetPaths
}
foreach ($module in $targetModules) {
    # Aspect.ModuleExtendedCommand
    &amp; { 
        &lt;#
        .SYNOPSIS
            Returns a module's extended commands
        .DESCRIPTION
            Returns the commands or scripts in a module that match the module command pattern.
            Each returned script will be decorated with the typename(s) that match,
            so that the extended commands can be augmented by the extended types system.
        .LINK
            Aspect.ModuleCommandPattern
        .EXAMPLE
            Aspect.ModuleExtensionCommand -Module PipeScript # Should -BeOfType ([Management.Automation.CommandInfo])
        #&gt;
        [Alias('Aspect.ModuleExtendedCommand')]
        param(
        # The name of a module, or a module info object.
        [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
        [ValidateScript({
        $validTypeList = [System.String],[System.Management.Automation.PSModuleInfo]
        $thisType = $_.GetType()
        $IsTypeOk =
            $(@( foreach ($validType in $validTypeList) {
                if ($_ -as $validType) {
                    $true;break
                }
            }))
        if (-not $isTypeOk) {
            throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','psmoduleinfo'."
        }
        return $true
        })]
        
        $Module,
        
        # A list of commands.
        # If this is provided, each command that is a valid extension will be returned.
        [Parameter(ValueFromPipelineByPropertyName)]
        [Management.Automation.CommandInfo[]]
        $Commands,
        # The suffix to apply to each named capture.
        # Defaults to '_Command'
        [Parameter(ValueFromPipelineByPropertyName)]
        [string]
        $Suffix = '_Command',
        # The prefix to apply to each named capture. 
        [Parameter(ValueFromPipelineByPropertyName)]
        [string]
        $Prefix,
        # The file path(s).  If provided, will look for commands within these paths.
        [Parameter(ValueFromPipelineByPropertyName)]
        [Alias('Fullname')]    
        $FilePath,
        # The PowerShell command type.  If this is provided, will only get commands of this type.
        [Parameter(ValueFromPipelineByPropertyName)]
        [Management.Automation.CommandTypes]
        $CommandType,
        # The base PSTypeName(s).
        # If provided, any commands that match the pattern will apply these typenames, too.
        [string[]]
        $PSTypeName
        )
        process {        
            if ($Module -is [string]) {
                $Module = Get-Module $Module
            }
            $ModuleInfo = $module
            if (-not $ModuleInfo) { return }
            
            $ModuleCommandPattern = # Aspect.ModuleExtensionPattern
                                    &amp; { 
                                        &lt;#
                                        .SYNOPSIS
                                            Outputs a module's extension pattern
                                        .DESCRIPTION
                                            Outputs a regular expression that will match any possible pattern.
                                        .EXAMPLE
                                            Aspect.ModuleCommandPattern -Module PipeScript # Should -BeOfType ([Regex])
                                        #&gt;
                                        [Alias('Aspect.ModuleCommandPattern')]
                                        param(
                                        # The name of a module, or a module info object.
                                        [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
                                        [ValidateScript({
                                        $validTypeList = [System.String],[System.Management.Automation.PSModuleInfo]
                                        $thisType = $_.GetType()
                                        $IsTypeOk =
                                            $(@( foreach ($validType in $validTypeList) {
                                                if ($_ -as $validType) {
                                                    $true;break
                                                }
                                            }))
                                        if (-not $isTypeOk) {
                                            throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','psmoduleinfo'."
                                        }
                                        return $true
                                        })]
                                        
                                        $Module,
                                        # The suffix to apply to each named capture.
                                        # Defaults to '_Command'
                                        [Parameter(ValueFromPipelineByPropertyName)]
                                        [string]
                                        $Suffix = '_Command',
                                        # The prefix to apply to each named capture. 
                                        [Parameter(ValueFromPipelineByPropertyName)]
                                        [string]
                                        $Prefix
                                        )
                                        process {
                                            if ($Module -is [string]) {
                                                $Module = Get-Module $Module
                                            }
                                            $ModuleInfo = $module
                                            #region Search for Module Extension Types
                                            if (-not $ModuleInfo) { return }
                                            $ModuleExtensionTypes = # Aspect.ModuleExtensionTypes
                                                                    &amp; { 
                                                                        &lt;#
                                                                        .SYNOPSIS
                                                                            Outputs a module's extension types
                                                                        .DESCRIPTION
                                                                            Outputs the extension types defined in a module's manifest.
                                                                        .EXAMPLE
                                                                            # Outputs a PSObject with information about extension command types.
                                                                            
                                                                            # The two primary pieces of information are the `.Name` and `.Pattern`.
                                                                            Aspect.ModuleExtensionType -Module PipeScript # Should -BeOfType ([PSObject])
                                                                        #&gt;
                                                                        [Alias('Aspect.ModuleCommandTypes','Aspect.ModuleCommandType','Aspect.ModuleExtensionTypes')]
                                                                        param(
                                                                        # The name of a module, or a module info object.
                                                                        [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
                                                                        [ValidateScript({
                                                                        $validTypeList = [System.String],[System.Management.Automation.PSModuleInfo]
                                                                        $thisType = $_.GetType()
                                                                        $IsTypeOk =
                                                                            $(@( foreach ($validType in $validTypeList) {
                                                                                if ($_ -as $validType) {
                                                                                    $true;break
                                                                                }
                                                                            }))
                                                                        if (-not $isTypeOk) {
                                                                            throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','psmoduleinfo'."
                                                                        }
                                                                        return $true
                                                                        })]
                                                                        
                                                                        $Module
                                                                        )
                                                                        begin {
                                                                            $ExtensionCollectionNames = 
                                                                                "Extension", "Command", "Cmdlet", "Function", "Alias", "Script", "Application", "File","Configuration"
                                                                            $ExtensionCollectionNames = @($ExtensionCollectionNames -replace '.+$','${0}Type') + @($ExtensionCollectionNames -replace '.+$','${0}Types')
                                                                        }
                                                                        process {
                                                                            #region Resolve Module Info
                                                                            if ($Module -is [string]) {
                                                                                $Module = Get-Module $Module
                                                                            }
                                                                            $ModuleInfo = $module                
                                                                            if (-not $ModuleInfo) { return }
                                                                            #endregion Resolve Module Info
                                                                            #region Check Cache and Hopefully Return
                                                                            if (-not $script:ModuleExtensionTypeCache) {
                                                                                $script:ModuleExtensionTypeCache = @{}
                                                                            }
                                                                            
                                                                            if ($script:ModuleExtensionTypeCache[$ModuleInfo]) {
                                                                                return $script:ModuleExtensionTypeCache[$ModuleInfo]
                                                                            }
                                                                            #endregion Check Cache and Hopefully Return
                                                                            #region Find Extension Types
                                                                            $modulePrivateData  = $ModuleInfo.PrivateData
                                                                            $SortedExtensionTypes = [Ordered]@{}
                                                                            foreach ($TypeOfExtensionCollection in $ExtensionCollectionNames) {
                                                                                $moduleExtensionTypes = 
                                                                                    if ($modulePrivateData.$TypeOfExtensionCollection) {
                                                                                        $modulePrivateData.$TypeOfExtensionCollection
                                                                                    } elseif ($modulePrivateData.PSData.$TypeOfExtensionCollection) {
                                                                                        $modulePrivateData.PSData.$TypeOfExtensionCollection
                                                                                    } else {
                                                                                        $null
                                                                                    }
                                                                                if (-not $moduleExtensionTypes) { continue } 
                                                                                foreach ($commandType in @($ModuleExtensionTypes.GetEnumerator() | Sort-Object Key)) {
                                                                                    if ($commandType.Value -is [Collections.IDictionary]) {
                                                                                        if (-not $commandType.Value.Name) {
                                                                                            $commandType.Value["Name"] = $commandType.Key
                                                                                        }
                                                                                        if (-not $commandType.Value.PSTypeName) {
                                                                                            $commandType.Value["PSTypeName"] = "$($module.Name).ExtensionCommandType"
                                                                                        }
                                                                                        $SortedExtensionTypes[$commandType.Name] = $commandType.Value
                                                                                    } else {
                                                                                        $SortedExtensionTypes[$commandType.Name] = [Ordered]@{
                                                                                            PSTypeName = "$($module.Name).ExtensionCommandType"
                                                                                            Name    = $commandType.Key
                                                                                            Pattern = $commandType.Value
                                                                                        }
                                                                                    }
                                                                                    if ($TypeOfExtensionCollection -notmatch '(?&gt;Extension|Command|Cmdlet)') {
                                                                                        $SortedExtensionTypes[$commandType.Name].CommandType = $TypeOfExtensionCollection -replace 'Type(?:s)?$'
                                                                                    } elseif ($TypeOfExtensionCollection -match 'Cmdlet') {
                                                                                        $SortedExtensionTypes[$commandType.Name].CommandType = "(?&gt;Alias|Function|Filter|Cmdlet)"
                                                                                    }
                                                                                }
                                                                            }
                                                                            
                                                                            $SortedExtensionTypes.PSTypeName="$($Module.Name).ExtensionCommandTypes"
                                                                            
                                                                            $script:ModuleExtensionTypeCache[$ModuleInfo] = [PSCustomObject]$SortedExtensionTypes
                                                                            $script:ModuleExtensionTypeCache[$ModuleInfo]
                                                                            #endregion Find Extension Types
                                                                        }    
                                                                     } -Module $moduleInfo
                                            
                                            if (-not $ModuleExtensionTypes) { return }
                                                
                                            # With some clever understanding of Regular expressions, we can make match any/all of our potential command types.
                                            # Essentially: Regular Expressions can look ahead (matching without changing the position), and be optional.
                                            # So we can say "any/all" by making a series of optional lookaheads.
                                            
                                            # We'll go thru each pattern in order
                                            $combinedRegex = @(foreach ($categoryExtensionTypeInfo in @($ModuleExtensionTypes.psobject.properties)) {
                                                $categoryPattern = $categoryExtensionTypeInfo.Value.Pattern                
                                                # ( and skip anyone that does not have a pattern)
                                                if (-not $categoryPattern) { continue } 
                                                '(?=' + # Start a lookahead
                                                    '.{0,}' + # match any or no characters
                                                    # followed by the command pattern
                                                    "(?&lt;$Prefix$($categoryExtensionTypeInfo.Name -replace '\p{P}', '_')$Suffix&gt;$categoryPattern)" +
                                                    ')?' # made optional                            
                                            }) -join [Environment]::NewLine
                                            # Now that we've combined the whole thing, make it a Regex and output it.        
                                            [Regex]::new("$combinedRegex", 'IgnoreCase,IgnorePatternWhitespace','00:00:01')
                                        }
                                     } $ModuleInfo -Prefix $prefix -Suffix $Suffix
            $ModuleCommandTypes   = # Aspect.ModuleExtensionType
                                    &amp; { 
                                        &lt;#
                                        .SYNOPSIS
                                            Outputs a module's extension types
                                        .DESCRIPTION
                                            Outputs the extension types defined in a module's manifest.
                                        .EXAMPLE
                                            # Outputs a PSObject with information about extension command types.
                                            
                                            # The two primary pieces of information are the `.Name` and `.Pattern`.
                                            Aspect.ModuleExtensionType -Module PipeScript # Should -BeOfType ([PSObject])
                                        #&gt;
                                        [Alias('Aspect.ModuleCommandTypes','Aspect.ModuleCommandType','Aspect.ModuleExtensionTypes')]
                                        param(
                                        # The name of a module, or a module info object.
                                        [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
                                        [ValidateScript({
                                        $validTypeList = [System.String],[System.Management.Automation.PSModuleInfo]
                                        $thisType = $_.GetType()
                                        $IsTypeOk =
                                            $(@( foreach ($validType in $validTypeList) {
                                                if ($_ -as $validType) {
                                                    $true;break
                                                }
                                            }))
                                        if (-not $isTypeOk) {
                                            throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','psmoduleinfo'."
                                        }
                                        return $true
                                        })]
                                        
                                        $Module
                                        )
                                        begin {
                                            $ExtensionCollectionNames = 
                                                "Extension", "Command", "Cmdlet", "Function", "Alias", "Script", "Application", "File","Configuration"
                                            $ExtensionCollectionNames = @($ExtensionCollectionNames -replace '.+$','${0}Type') + @($ExtensionCollectionNames -replace '.+$','${0}Types')
                                        }
                                        process {
                                            #region Resolve Module Info
                                            if ($Module -is [string]) {
                                                $Module = Get-Module $Module
                                            }
                                            $ModuleInfo = $module                
                                            if (-not $ModuleInfo) { return }
                                            #endregion Resolve Module Info
                                            #region Check Cache and Hopefully Return
                                            if (-not $script:ModuleExtensionTypeCache) {
                                                $script:ModuleExtensionTypeCache = @{}
                                            }
                                            
                                            if ($script:ModuleExtensionTypeCache[$ModuleInfo]) {
                                                return $script:ModuleExtensionTypeCache[$ModuleInfo]
                                            }
                                            #endregion Check Cache and Hopefully Return
                                            #region Find Extension Types
                                            $modulePrivateData  = $ModuleInfo.PrivateData
                                            $SortedExtensionTypes = [Ordered]@{}
                                            foreach ($TypeOfExtensionCollection in $ExtensionCollectionNames) {
                                                $moduleExtensionTypes = 
                                                    if ($modulePrivateData.$TypeOfExtensionCollection) {
                                                        $modulePrivateData.$TypeOfExtensionCollection
                                                    } elseif ($modulePrivateData.PSData.$TypeOfExtensionCollection) {
                                                        $modulePrivateData.PSData.$TypeOfExtensionCollection
                                                    } else {
                                                        $null
                                                    }
                                                if (-not $moduleExtensionTypes) { continue } 
                                                foreach ($commandType in @($ModuleExtensionTypes.GetEnumerator() | Sort-Object Key)) {
                                                    if ($commandType.Value -is [Collections.IDictionary]) {
                                                        if (-not $commandType.Value.Name) {
                                                            $commandType.Value["Name"] = $commandType.Key
                                                        }
                                                        if (-not $commandType.Value.PSTypeName) {
                                                            $commandType.Value["PSTypeName"] = "$($module.Name).ExtensionCommandType"
                                                        }
                                                        $SortedExtensionTypes[$commandType.Name] = $commandType.Value
                                                    } else {
                                                        $SortedExtensionTypes[$commandType.Name] = [Ordered]@{
                                                            PSTypeName = "$($module.Name).ExtensionCommandType"
                                                            Name    = $commandType.Key
                                                            Pattern = $commandType.Value
                                                        }
                                                    }
                                                    if ($TypeOfExtensionCollection -notmatch '(?&gt;Extension|Command|Cmdlet)') {
                                                        $SortedExtensionTypes[$commandType.Name].CommandType = $TypeOfExtensionCollection -replace 'Type(?:s)?$'
                                                    } elseif ($TypeOfExtensionCollection -match 'Cmdlet') {
                                                        $SortedExtensionTypes[$commandType.Name].CommandType = "(?&gt;Alias|Function|Filter|Cmdlet)"
                                                    }
                                                }
                                            }
                                            
                                            $SortedExtensionTypes.PSTypeName="$($Module.Name).ExtensionCommandTypes"
                                            
                                            $script:ModuleExtensionTypeCache[$ModuleInfo] = [PSCustomObject]$SortedExtensionTypes
                                            $script:ModuleExtensionTypeCache[$ModuleInfo]
                                            #endregion Find Extension Types
                                        }    
                                     } $ModuleInfo
            
            $commands    =
                @(
                if ($PSBoundParameters['Commands']) {
                    $commands
                }
                elseif ($PSBoundParameters['FilePath']) {
                    if (-not $commandType) {
                        $commandType = 'Application,ExternalScript'
                    }
                    foreach ($file in Get-ChildItem -File -Path $PSBoundParameters['FilePath'] -Recurse) {
                        $ExecutionContext.SessionState.InvokeCommand.GetCommand($file.FullName, $commandType)
                    }
                } else {
                    if (-not $CommandType) {
                        $commandType = 'Function,Alias,Filter,Cmdlet'
                    }
                    $ExecutionContext.SessionState.InvokeCommand.GetCommands('*', $commandType, $true)
                })
            :nextCommand foreach ($cmd in $commands) {            
                $matched = $ModuleCommandPattern.Match("$cmd")
                if (-not $matched.Success) { continue }
                $NamedGroupMatch = $false
                :nextCommandType foreach ($group in $matched.Groups) {
                    if (-not $group.Success) { continue }
                    if ($null -ne ($group.Name -as [int])) { continue }                
                    $CommandTypeName     = $group.Name.Replace('_','.')
                    $ThisCommandsType    = $ModuleCommandTypes.($group.Name -replace "^$prefix" -replace "$suffix$")
                    if ($ThisCommandsType) {
                        $ThisTypeFilter = @($ThisCommandsType.CommandType,$ThisCommandsType.CommandTypes -ne $null)[0]
                        if ($ThisTypeFilter -and ($cmd.CommandType -notmatch $ThisTypeFilter)) {
                            continue nextCommandType
                        }
                        $ThisExcludeFilter = @($ThisCommandsType.ExcludeCommandType,$ThisCommandsType.ExcludeCommandTypes -ne $null)[0]
                        if ($ThisExcludeFilter -and ($cmd.CommandType -match $ThisExcludeFilter)) {
                            continue nextCommandType
                        }
                    }
                    $NamedGroupMatch     = $true
                    if ($PSTypeName) {
                        foreach ($psuedoType in $PSTypeName) {
                            if ($cmd.pstypenames -notcontains $psuedoType) {
                                $cmd.pstypenames.insert(0, $psuedoType)        
                            }
                        }
                    }
                    if ($cmd.pstypenames -notcontains $CommandTypeName) {
                        $cmd.pstypenames.insert(0, $CommandTypeName)
                    }
                }
                if ($NamedGroupMatch) {
                    $cmd
                }
            }
        }
     } -Module $module @Splat
}

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>GetDynamicParameters</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets dynamic parameters
.DESCRIPTION
    Gets dynamic parameters for a command
#&gt;
param(    
    $InvocationName,

    [Collections.IDictionary]
    $DyanmicParameterOption = [Ordered]@{
        ParameterSetName='__AllParameterSets'
        NoMandatory = $true
    }
)

$this.ExtensionsOf($InvocationName) | 
    # Aspect.DynamicParameter
    &amp; { 
        &lt;#
        .SYNOPSIS
            Dynamic Parameter Aspect
        .DESCRIPTION
            The Dynamic Parameter Aspect is used to add dynamic parameters, well, dynamically.
            It can create dynamic parameters from one or more input objects or scripts.
        .EXAMPLE
            Get-Command Get-Command | 
                Aspect.DynamicParameter
        .EXAMPLE
            Get-Command Get-Process | 
                Aspect.DynamicParameter -IncludeParameter Name # Select -Expand Keys | Should -Be Name
        #&gt;
        [Alias('Aspect.DynamicParameters')]
        param(
        # The InputObject.
        # This can be anything, but will be ignored unless it is a `[ScriptBlock]` or `[Management.Automation.CommandInfo]`.    
        [Parameter(ValueFromPipeline)]
        $InputObject,
        # The name of the parameter set the dynamic parameters will be placed into.    
        [string]
        $ParameterSetName,
        # The positional offset.  If this is provided, all positional parameters will be shifted by this number.
        # For example, if -PositionOffset is 1, the first parameter would become the second parameter (and so on)
        [int]
        $PositionOffset,
        # If set, will make all dynamic parameters non-mandatory.
        [switch]
        $NoMandatory,
        # If provided, will check that dynamic parameters are valid for a given command.
        # If the [Management.Automation.CmdletAttribute]
        [string[]]
        $commandList,
        # If provided, will include only these parameters from the input.
        [string[]]
        $IncludeParameter,
        # If provided, will exclude these parameters from the input.
        [string[]]
        $ExcludeParameter,
        # If provided, will make a blank parameter for every -PositionOffset.
        # This is so, presumably, whatever has already been provided in these positions will bind correctly.
        # The name of this parameter, by default, will be "ArgumentN" (for example, Argument1)
        [switch]
        $BlankParameter,
        # The name of the blank parameter.
        # If there is a -PositionOffset, this will make a blank parameter by this name for the position.    
        [string[]]
        $BlankParameterName = "Argument"
        )
        begin {
            $inputQueue = [Collections.Queue]::new()
        }
        process {
            $inputQueue.Enqueue($InputObject)
        }
        end {        
            $DynamicParameters = [Management.Automation.RuntimeDefinedParameterDictionary]::new()
            if ($PositionOffset -and 
                ($BlankParameter -or $PSBoundParameters['BlankParameterName'])) {
                for ($pos =0; $pos -lt $PositionOffset; $pos++) {
                    $paramName = $BlankParameterName[$pos]
                    if (-not $paramName) {
                        $paramName = "$($BlankParameterName[-1])$pos"
                    }                
                    $DynamicParameters.Add($paramName, 
                        [Management.Automation.RuntimeDefinedParameter]::new(
                            $paramName,
                            [PSObject], 
                            @(
                                $paramAttr = [Management.Automation.ParameterAttribute]::new()
                                $paramAttr.Position = $pos
                                $paramAttr
                            )
                        )
                    )
                }
            }
            while ($inputQueue.Count) {
                $InputObject = $inputQueue.Dequeue()
                $inputCmdMetaData = 
                    if ($inputObject -is [Management.Automation.CommandInfo]) {
                        [Management.Automation.CommandMetaData]$InputObject
                    }
                    elseif ($inputObject -is [scriptblock]) {
                        $function:TempFunction = $InputObject
                        [Management.Automation.CommandMetaData]$ExecutionContext.SessionState.InvokeCommand.GetCommand('TempFunction','Function')
                    }
                if (-not $inputCmdMetaData) { continue } 
                                            
                :nextDynamicParameter foreach ($paramName in $inputCmdMetaData.Parameters.Keys) {
                    if ($ExcludeParameter) {
                        foreach ($exclude in $ExcludeParameter) {
                            if ($paramName -like $exclude) { continue nextDynamicParameter}
                        }
                    }
                    if ($IncludeParameter) {
                        $shouldInclude = 
                            foreach ($include in $IncludeParameter) {
                                if ($paramName -like $include) { $true;break}
                            }
                        if (-not $shouldInclude) { continue nextDynamicParameter }
                    }
                    $attrList = [Collections.Generic.List[Attribute]]::new()
                    $validCommandNames = @()
                    foreach ($attr in $inputCmdMetaData.Parameters[$paramName].attributes) {
                        if ($attr -isnot [Management.Automation.ParameterAttribute]) {
                            # we can passthru any non-parameter attributes
                            $attrList.Add($attr)
                            # (`[Management.Automation.CmdletAttribute]` is special, as it indicates if the parameter applies to a command)
                            if ($attr -is [Management.Automation.CmdletAttribute] -and $commandList) {
                                $validCommandNames += (
                                    ($attr.VerbName -replace '\s') + '-' + ($attr.NounName -replace '\s')
                                ) -replace '^\-' -replace '\-$'
                            }
                        } else {
                            # but parameter attributes need to copied.
                            $attrCopy = [Management.Automation.ParameterAttribute]::new()
                            # (Side note: without a .Clone, copying is tedious.)
                            foreach ($prop in $attrCopy.GetType().GetProperties('Instance,Public')) {
                                if (-not $prop.CanWrite) { continue }
                                if ($null -ne $attr.($prop.Name)) {
                                    $attrCopy.($prop.Name) = $attr.($prop.Name)
                                }
                            }
                            $attrCopy.ParameterSetName =
                                if ($ParameterSetName) {
                                    $ParameterSetName
                                }
                                else {
                                    $defaultParamSetName = $inputCmdMetaData.DefaultParameterSetName
                                    if ($attrCopy.ParameterSetName -ne '__AllParameterSets') {
                                        $attrCopy.ParameterSetName
                                    }
                                    elseif ($defaultParamSetName) {
                                        $defaultParamSetName
                                    }
                                    elseif ($this -is [Management.Automation.FunctionInfo]) {
                                        $this.Name
                                    } elseif ($this -is [Management.Automation.ExternalScriptInfo]) {
                                        $this.Source
                                    }
                                }
                            if ($NoMandatory -and $attrCopy.Mandatory) {
                                $attrCopy.Mandatory = $false
                            }
                            if ($PositionOffset -and $attr.Position -ge 0) {
                                $attrCopy.Position += $PositionOffset
                            }
                            $attrList.Add($attrCopy)
                        }
                    }
                    if ($commandList -and $validCommandNames) {
                        :CheckCommandValidity do {
                            foreach ($vc in $validCommandNames) {
                                if ($commandList -match $vc) { break CheckCommandValidity }
                            }
                            continue nextDynamicParameter
                        } while ($false)
                    }
                    
                    if ($DynamicParameters.ContainsKey($paramName)) {                    
                        $DynamicParameters[$paramName].ParameterType = [PSObject]                    
                        foreach ($attr in $attrList) {                        
                            $DynamicParameters[$paramName].Attributes.Add($attr)
                        }
                    } else {
                        $DynamicParameters.Add($paramName, [Management.Automation.RuntimeDefinedParameter]::new(
                            $inputCmdMetaData.Parameters[$paramName].Name,
                            $inputCmdMetaData.Parameters[$paramName].ParameterType,
                            $attrList
                        ))
                    }
                }
            }
            $DynamicParameters
        }
     } @DyanmicParameterOption

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>GetExtendedParameters</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets extended parameters
.DESCRIPTION
    Gets the extended parameters for an invocation name.

    Parameters will be mapped to any valid extensions of this invocation name.
    
    If there are enough valid parameters to run a parameter set, a dictionary of parameters will be returned.
#&gt;

param(
    # The invocation name
    [string]$InvocationName,
    # A collection of parameters
    [Collections.IDictionary]$params, 
    # The parameter set name.  If not provided, all valid parameter sets will be examined.
    [string]$ParameterSetName
)

# Get extensions for the invocationname 
foreach ($extensionCommand in $this.ExtensionsOf($InvocationName)) {
    :nextParameterSet foreach ($paramSet in $extensionCommand.ParameterSets) {
        if ($ParameterSetName -and $paramSet.Name -ne $ParameterSetName) { continue }
        $mappedParams = [Ordered]@{} # Create a collection of mapped parameters
        $mandatories  =  # Walk thru each parameter of this command
            @(foreach ($myParam in $paramSet.Parameters) {
                if ($params.Contains($myParam.Name)) { # If this was in Params,
                    $mappedParams[$myParam.Name] = $params[$myParam.Name] # then map it.
                } else {
                    foreach ($paramAlias in $myParam.Aliases) { # Otherwise, check the aliases
                        if ($params.Contains($paramAlias)) { # and map it if the parameters had the alias.
                            $mappedParams[$myParam.Name] = $params[$paramAlias]
                            break
                        }
                    }
                }
                if ($myParam.IsMandatory) { # If the parameter was mandatory,
                    $myParam.Name # keep track of it.
                }
            })
    
        # Check for parameter validity.
        foreach ($mappedParamName in @($mappedParams.Keys)) {
            if (-not $this.IsParameterValid($exensionCommand, $mappedParamName, $mappedParams[$mappedParamName])) {
                $mappedParams.Remove($mappedParamName)
            }
        }
        
        foreach ($mandatoryParam in $mandatories) { # Walk thru each mandatory parameter.
            if (-not $mappedParams.Contains($mandatoryParam)) { # If it wasn't in the parameters.
                continue nextParameterSet
            }
        }
        $mappedParams.psobject.properties.Add([psnoteproperty]::new('Command',$extensionCommand))
        $mappedParams
    }    
}



                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>IsParameterValid</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Determines if a parameter is valid
.DESCRIPTION
    Determines if a command's parameter value is valid.
#&gt;
param(
    # The command
    [Parameter(Mandatory)]
    [Management.Automation.CommandInfo]    
    $Command,
    # Th parameter name
    [Parameter(Mandatory)]
    $ParameterName,
    
    # The value
    [PSObject]
    $Value
)

if ($Command.Parameters.Count -ge 0 -and 
    $Command.Parameters[$parameterName].Attributes
) {
    foreach ($attr in $Command.Parameters[$parameterName].Attributes) {
        $_ = $value
        if ($attr -is [Management.Automation.ValidateScriptAttribute]) {
            $result = try { . $attr.ScriptBlock } catch { $null }
            if ($result -ne $true) {
                return $false
            }
        }
        elseif ($attr -is [Management.Automation.ValidatePatternAttribute] -and 
                (-not [Regex]::new($attr.RegexPattern, $attr.Options, '00:00:05').IsMatch($value))
            ) {
                return $false
            }
        elseif ($attr -is [Management.Automation.ValidateSetAttribute] -and 
                $attr.ValidValues -notcontains $value) {
                    return $false
                }
        elseif ($attr -is [Management.Automation.ValidateRangeAttribute] -and (
            ($value -gt $attr.MaxRange) -or ($value -lt $attr.MinRange)
        )) {
            return $false
        }
    }
}
return $true
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Extension</Name>
        <GetScriptBlock>
                        $this.FindExtensions($this, ($This | Split-Path))

                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
</Types>
